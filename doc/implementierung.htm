<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- TemplateBeginEditable name="doctitle" -->
<title>Negation Detection - Implementierung</title>
<!-- TemplateEndEditable -->
<!-- TemplateBeginEditable name="head" -->
<!-- TemplateEndEditable -->
<link href="./style.css" rel="stylesheet" type="text/css" />
<!--[if IE 5]>
<style type="text/css"> 
/* place css box model fixes for IE 5* in this conditional comment */
.twoColFixLtHdr #sidebar1 { width: 230px; }
</style>
<![endif]--><!--[if IE]>
<style type="text/css"> 
/* place css fixes for all versions of IE in this conditional comment */
.twoColFixLtHdr #sidebar1 { padding-top: 30px; }
.twoColFixLtHdr #mainContent { zoom: 1; }
/* the above proprietary zoom property gives IE the hasLayout it needs to avoid several bugs */
</style>
<![endif]-->
<style type="text/css">
<!--
.style1 {
	color: #999900;
	font-style: italic;
}
-->
</style>
</head>

<body class="twoColFixLtHdr">

<div id="container">
  <div id="header">
    <h1>Negation Detection</h1>
  <!-- end #header --></div>
  <div id="sidebar1"> 
    <h3>Navigation</h3>
    <p><a href="./index.htm">Home</a> </p>
    <p><a href="./implementierung.htm">Implementierung</a></p>
    <p><a href="./auswertung.htm">Auswertung</a></p>
    <p><a href="./referenzen.htm">Referenzen</a></p>
  <!-- end #sidebar1 --></div>
  <div id="mainContent">
    <h2 align="justify">Implementierung</h2>
    <p align="justify">Das Herausfiltern von Adverbnegationen geschieht in mehreren Schritten.</p>
    <p align="justify">Zuerst muss der Satzbau analysiert, die Wortart jedes einzelnen Wort bestimmt und anschließend in Zusammenhang gebracht werden. Diese nicht-triviale Aufgabe übernimmt in unserer Implementierung der Stanford-Parser <a href="./referenzen.htm">[2]</a>. Diesem wird ein Satz übergeben, welcher verarbeitet und in einen Baum umgewandelt wird. Dieser Baum beinhaltet die Informationen über den Inhalt des Satzes, die Wortarten und deren Zusammenhang. Beispielsweise kann sich ein Satz in eine <em>Noun-Phrase</em> und in eine <em>Verb-Phrase</em> gliedern, deren Kinder entweder in ein Terminal, also in ein Wort, oder in ein Non-terminal münden können, beispielsweise in eine weitere <em>Noun-Phrase</em> oder in eine <em>Adjective-Phrase</em>.</p>
    <p align="justify">Die Information über das Vorhandensein einer Adverbnegation lässt sich anhand der Struktur um ein Negationswort gewinnen. In unserem Fall sind berücksichtigte Negationswörter <em>not</em> und <em>n't</em>. Mit Hilfe so genannter <em>Tregex</em>, in Anlehnung an die bei Perl bekannten Regular Expressions, können Regeln in Bezug auf das Verhältnis bestimmter Knoten im Baum zueinander ausformuliert werden. Dabei stehen einem Regeln wie 'A ist ein direkter Unterknoten von B', 'A ist ein Nachbarknoten von B' oder 'A ist ein Überknoten von B und ist mittels einer ununterbrochenen Kette mit Knoten C verbunden' zur Verfügung. Details können in der Dokumentation des Stanford-Parsers <a href="./referenzen.htm">[2]</a> nachgelesen werden. Eine Adverbnegation lässt sich in</p>
    <ul>
      <li>das Negationswort</li>
      <li>ein Negationsmuster, und</li>
      <li>eine Negationsphrase</li>
    </ul>
    <p align="justify">      unterteilen. Bei einem Satz, wie zum Beispiel</p>
    <p align="center"><span class="style1">The right moment hasn't been awaited.</span> </p>
    <p align="justify">ist das Negationswort <span class="style1">n't</span>, das Negationsmuster <span class="style1">hasn't been awaited</span> und die Negationsphrase <span class="style1">The right moment</span>. Der Algorithmus zum Herausfiltern dieser Teile wird im nächsten Absatz beschrieben.</p>
    <p align="justify">Zuerst wird der Satz nach einem Negationswort durchsucht. Dies geschieht mittels einer relativ einfachen Tregex, wobei versucht wird False Positives auszuschließen. Da die Negationsschlüsselwörter nur in wenigen Fälle für Muster vorkommen, die keine Adverbnegationen darstellen, ist das Herausfiltern nicht so schwierig. Wurde ein Negationswort gefunden, wird versucht, das entsprechende Muster ausgehend von diesem Wort herauszulösen. Auf dieselbe Weise geschieht das Herausfinden des Patterns. Ein Negationsmuster lässt sich grob in drei Arten unterteilen. Für jede Art gibt es zwei Tregex:</p>
    <ul>
      <li>eine spezielle, die das Muster sucht und jene Kinder des relevanten Baums, die nicht zum Muster gehören, wegschneidet</li>
      <li>eine allgemeinere, die auch auf Bäume reagiert, die keine Kinder zuviel haben</li>
    </ul>
    <p align="justify">Zuerst wird versucht die speziellere Tregex anzuwenden, anschließend die allgemeinere. Dabei werden Fehler, wie zum Beispiel, dass sich keine Tregex anwenden lassen, obwohl ein Negationswort gefunden wurde, oder dass sich mehr als nur ein Tregex anwenden lässt mit geloggt. Wurden alle Negationswörter eines Satzes verarbeitet, wird ein NegationData Objekt zur Weiterverarbeitung zurückgegeben, das alle relevanten Informationen enthält.</p>
  </div>
	<!-- This clearing element should immediately follow the #mainContent div in order to force the #container div to contain all child floats --><br class="clearfloat" />
  <div id="footer">
    <p>&copy; Andreas Bernauer 0627051, Jochen Goeritz 0627057, Dirk Wallerstorfer 0626775</p>
  <!-- end #footer --></div>
<!-- end #container --></div>
</body>
</html>
